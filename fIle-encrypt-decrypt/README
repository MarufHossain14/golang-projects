At first we accept arguments from the user, then we validate if the file exists or not, then we get the password and validate it, if the password matches we encrypt the file or decrypt the file.
there are basically two parts here, one is encryption and one is decryption:
Encryption :
it first checks for source file, then it opens it and then reads plain text from the source file, then we create an empty variable called "nonce" it will be 12 bytes in our case, then we will randomize the nonce, then we will get the password from the user, and then there are several key components such as:
1 - byte length
2 - SHA- 1
3 - iterations

we are using Password-Based Key Derivation Function - which is basically a function in which a key is generated from the password, and can be used as an encryption key or as a hash value, this is basically hashing the password.
so for example this is when how take a users pass and hash it and store it in a database, because we dont want to directly store the password in the database, as there are chances that someone can hack the database and get the passwords. so the salt here is the nonce.

so after that we get a derived key, then we will run the derived key through the aes (Advanced Encryption Standard) cipher , this will give some more solid encryption abilities.
then we will get a cipher block.

then we will run the cipher block through Galois Counter mode, which basically gives us more encryption with data integrity checks.
GCM generates a tag, whcih is appended to the ciphertext. This tag is used to verify the integrity of the data upon decryption.
GCM uses AES to encrypt the plaintext data, it operates in a counter mode (hence the name) and generates a stream of encrypted blocks.

and then we will run this through the aesgcm.SEAL function, aesgcm is why we did all the above stuff and the main stuff is SEAl which converts plaintext from file and converts it into ciphertext, then it creates a source file for encrypted data and writes ciphertext to the new source code file.


for the decryption part, it is basically the reverse of encryption, first we check for source file, then we open it and read the ciphertext from the source file, then we get the nonce from the user, then we get the password from the user, then we derive the key using the same method as above, then we create a cipher block using aes cipher and then we create a gcm using the cipher block, then we run the gcm through aesgcm.OPEN function which converts ciphertext back to plaintext, then we create a new source file for decrypted data and write plaintext to the new source file.
